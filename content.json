[{"title":"三十分钟掌握ES6/ES2015核心内容","date":"2017-01-04T14:57:06.000Z","path":"2017/01/04/三十分钟掌握ES6-ES2015核心内容/","text":"++ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…在我们正式讲解ES6语法之前，我们得先了解下Babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： 最常用的ES6特性 let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。 LET, CONST这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子：1234567var name = 'zach'while (true) &#123; var name = 'obama' console.log(name) //obama break&#125;console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。1234567let name = 'zach'while (true) &#123; let name = 'obama' console.log(name) //obama break&#125;console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。123456var clickBoxs = document.querySelectorAll('.clickBox')for (var i = 0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = function()&#123; console.log(i) &#125;&#125; 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。12345678910function iteratorFactory(i)&#123; var onclick = function(e)&#123; console.log(i) &#125; return onclick;&#125;var clickBoxs = document.querySelectorAll('.clickBox')for (var i = 0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = iteratorFactory(i)&#125; const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12const PI = Math.PIPI = 23 //Module build failed: SyntaxError: /es6/app.js: \"PI\" is read-only 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require('moment') CLASS, EXTENDS, SUPER这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？ 有了ES6我们不再烦恼！ ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档 ARROW FUNCTION(箭头函数)这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:12function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; i + 1 //ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来：123456function(x, y) &#123; x++; y--; return x + y;&#125;(x, y) =&gt; &#123;x++; y--; return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：12345678910111213class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this12345says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + &apos; says &apos; + say) &#125;, 1000) 2.第二种方法是用bind(this),即1234says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;.bind(this), 1000) 但现在我们有了箭头函数，就不需要这么麻烦了：123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 TEMPLATE STRING这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。 大家可以先看下面一段代码：123456$(\"#result\").append( \"There are &lt;b&gt;\" + basket.count + \"&lt;/b&gt; \" + \"items in your basket, \" + \"&lt;em&gt;\" + basket.onSale + \"&lt;/em&gt; are on sale!\"); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（\\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！ React Router从第1.0.3版开始也使用ES6语法了，比如这个例子：1&lt;Link to=&#123;`/taco/$&#123;taco.name&#125;`&#125;&gt;&#123;taco.name&#125;&lt;/Link&gt; ` DESTRUCTURINGES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 看下面的例子：1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 用ES6完全可以像下面这么写：1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 反过来可以这么写：123let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 DEFAULT, RESTdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。12345function animal(type)&#123; type = type || 'cat' console.log(type)&#125;animal() 如果用ES6我们而已直接这么写：1234function animal(type = 'cat')&#123; console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子：1234function animals(...types)&#123;console.log(types)&#125;animals('cat', 'dog', 'fish') //[\"cat\", \"dog\", \"fish\"] 而如果不用ES6的话，我们则得使用ES5的arguments。 IMPORT EXPORT这两个家伙对应的就是es6自己的module功能。 我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 一方面js代码变得很臃肿，难以维护另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。如果想了解更多AMD，尤其是require.js，可以参看这个教程：modules on the web are useful and the mechanisms that can be used on the web today to enable them 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码…传统的写法 首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？ 首先定义：1234//content.jsdefine('content.js', function()&#123; return 'A cat';&#125;) 然后require：1234//index.jsrequire(['./content.js'], function(animal)&#123; console.log(animal); //A cat&#125;) 那CommonJS是怎么写的呢？12345//index.jsvar animal = require('./content.js')//content.jsmodule.exports = 'A cat' ES6的写法12345//index.jsimport animal from './content'//content.jsexport default 'A cat' 以上我把三者都列出来了，妈妈再也不用担心我写混淆了… ES6 MODULE的其他高级用法1234567//content.jsexport default 'A cat' export function say()&#123; return 'Hello!'&#125; export const type = 'dog' 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）12345//index.jsimport &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125;`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。123456//index.jsimport animal, &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 修改变量名 此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。123456//index.jsimport animal, &#123; say, type as animalType &#125; from './content' let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 模块的整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。123456//index.jsimport animal, * as content from './content' let says = content.say()console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。 终极秘籍 考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量： import { type } from ‘./content’由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 ES6帮我们实现了！ 不过，目前无论是webpack还是browserify都还不支持这一功能… 如果你现在就想实现这一功能的话，可以尝试使用rollup.js 他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。 看看他们官方的解释吧： Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It’s a revolution in how we use libraries in JavaScript, and it’s happening right now. 文章来源：https://segmentfault.com/a/1190000004365693","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"},{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"测试分享音乐","date":"2016-12-25T20:04:11.000Z","path":"2016/12/26/测试分享音乐/","text":"这是之前在学校负责的一张纯音乐(吉他)专辑。这里使用iframe插入网易云音乐在线播放器","tags":[{"name":"音乐分享","slug":"音乐分享","permalink":"http://vicenlaw.com/tags/音乐分享/"}]},{"title":"Java生成验证码，保存到指定目录","date":"2016-12-25T19:36:58.000Z","path":"2016/12/26/Java生成验证码，保存到指定目录/","text":"前段时间，帮一个朋友弄个登录界面，用到了java生成验证码。config_verifyCode.xml是配置保存目录。如需改动保存目录，直接改xml配置即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import java.awt.*;import java.awt.image.BufferedImage;import java.io.*;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.*;import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.InputSource; public class RandCodeImage extends HttpServlet&#123; public RandCodeImage() &#123; lineWidth = 2; width = 90; height = 32; count = 200; randomCode = null; x = 0; codeNum = 4; &#125; public void init() throws ServletException &#123; String strCodeNums = getInitParameter(\"codeCount\"); String strW = getInitParameter(\"width\"); String strH = getInitParameter(\"height\"); try &#123; if(strH != null &amp;&amp; strH.length() != 0) height = Integer.parseInt(strH); if(strW != null &amp;&amp; strW.length() != 0) width = Integer.parseInt(strW); if(strCodeNums != null &amp;&amp; strCodeNums.length() != 0) codeNum = Integer.parseInt(strCodeNums); &#125; catch(NumberFormatException numberformatexception) &#123; &#125; x = width / (codeNum + 1); System.out.println(\"xx = \" + x); fontHeight = height - 2; codeY = height - 4; &#125; private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if(fc &gt; 255) fc = 255; if(bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sessionName = request.getParameter(\"sessionName\"); if(sessionName == null || sessionName.length() == 0) sessionName = \"rand\"; this.x = width / (codeNum + 1); fontHeight = height - 4; codeY = height - 4; response.setHeader(\"Pragma\", \"No-cache\"); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setDateHeader(\"Expires\", 0L); BufferedImage image = new BufferedImage(width, height, 1); Graphics2D g = (Graphics2D)image.getGraphics(); Random random = new Random(); g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); fontHeight = height - 2; Font font = new Font(\"Fixedsys\", 0, fontHeight); g.setFont(font); g.setColor(getRandColor(0, 20)); g.drawRect(0, 0, width - 1, height - 1); g.setColor(getRandColor(200, 250)); g.setColor(Color.BLACK); g.drawRect(0, 0, width - 1, height - 1); g.setColor(getRandColor(160, 200)); for(int j = 0; j &lt; 20; j++) &#123; int x = random.nextInt(width - lineWidth - 1) + 1; int y = random.nextInt(height - lineWidth - 1) + 1; int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; String sRand = \"\"; int R = 0; int G = 0; int B = 0; for(int i = 0; i &lt; 4; i++) &#123; String rand = String.valueOf(codes[random.nextInt(32)]); sRand = sRand + rand; R = random.nextInt(255); G = random.nextInt(255); B = random.nextInt(255); g.setColor(new Color(R, G, B)); g.drawString(rand, (i + 1) * this.x, codeY); &#125; g.dispose(); long lasting = System.currentTimeMillis(); String yzmpath = null; try&#123; File f = new File(\"config_verifyCode.xml\"); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(f); NodeList nl = doc.getElementsByTagName(\"VALUE\"); for (int i=0;i&lt;nl.getLength();i++)&#123; yzmpath = doc.getElementsByTagName(\"Dir\").item(i).getFirstChild().getNodeValue(); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;ImageIO.write(image, \"JPEG\", new File(yzmpath + sRand.toString() + \".jpg\")); response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(\"&lt;!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"&gt;\"); out.println(\"&lt;HTML&gt;\"); out.println(\" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet Out VerifyCode&lt;/TITLE&gt;&lt;/HEAD&gt;\"); out.println(\" &lt;BODY&gt;\"); out.println(\" &lt;t0&gt;\" + sRand.toString() + \"&lt;/t0&gt;\"); out.println(\" &lt;/BODY&gt;\"); out.println(\"&lt;/HTML&gt;\"); out.flush(); out.close(); &#125; private int lineWidth; private int width; private int height; private int count; StringBuffer randomCode; char codes[] = &#123; '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; private int x; private int fontHeight; private int codeY; private int codeNum;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://vicenlaw.com/tags/Java/"}]},{"title":"Js数组方法","date":"2016-12-24T17:09:58.000Z","path":"2016/12/25/Js数组方法/","text":"数组方法1、Array.prototype.join()将数组中所有元素化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分割数组的各个元素。如不指定分隔符，默认使用逗号。123456var a = [1, 2, 3];a.join(); // =&gt; \"1,2,3\"a.join(\" \"); // =&gt; \"1 2 3\"a.join(\"\"); // =&gt; \"123\"var b = new Array(3); //长度为3的空数组b.join(\"-\"); // -&gt; \"--\" 2、Array.prototype.reverse()将数组的元素颠倒顺序，返回逆序的数组。12var a = [1, 2, 3];a.reverse(); // a = [3, 2, 1] 3、Array.prototype.sort()将数组中的元素排序，并返回排序后的数组。不带参数的时候，默认以字母表顺序排序（如有必要将临时转化为字符串进行比较）12345678910111213141516171819var a = new Array(\"banana\", \"cherry\", \"apple\");a.sort() // a = [\"apple\", \"banana\", \"cherry\"]//如果数组包含undefined元素，将会排到数组尾部var b = [22, 1, 111, 333];b.sort(); //字母表顺序: b = [1, 111, 22, 333];b.sort(function(a,b)&#123;return a-b;&#125;); //数值排序 b = [1, 22, 111, 333]b.sort(function(a,b)&#123;return b-a;&#125;); //数值大小相反排序//字母大小var c = [\"Dog\", \"Apple\", \"banana\", \"apple\"]；//区分大小写 结果为c=[\"Apple\", \"Dog\", \"apple\", \"banana\"]c.sort(); //不区分大小写，先将参数转化为小写字符串再比较。结果为c=[\"apple\", \"Apple\", \"banana\"， \"Dog\"]c.sort(function (s, t)&#123; var a = s.toLowerCase(); var b = t.toLowerCase(); if(a&lt;b) return -1; if(a&gt;b) return 1; return 0;&#125;); 4、Array.prototype.concat()连接两个或更多的数组，并返回结果。 5、Array.prototype.slice()从某个已有的数组返回选定的元素Array.prototype.slice(start,end)start ：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标（即不包含该参数指定位置）。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。注意： 6、Array.prototype.splice()向数组中添加/删除元素Array.prototype.splice(index,howmany,item1,..itemX)index：必需，整数，方法开始位置howmany：必需，需要删除元素的数量，如果为0则不删除。item1：可选，向数组添新的元素123456789101112var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"&lt;br /&gt;\") //George,John,Thomas,James,Adrew,Martin arr.splice(2,0,\"William\") document.write(arr + \"&lt;br /&gt;\") //George,John,William,Thomas,James,Adrew,Martin //注意，不是结果不是George,John,Thomas,William,James,Adrew,Martin 7、Array.prototype.push() , Array.prototype.pop()push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度；pop()方法删除数组最后一个元素，减小数组长度并返回它删除的值。注意：两个方法都修改并替换原始数组，而不是生成一个修改版的新数组。 8、Array.prototype.unshift() , Array.shift()unshift()向数组的开头添加一个或更多元素，并返回新的长度。shift()删除并返回数组的第一个元素 9、Array.prototype.toString() , Array.toLocaleString()toString()将每个元素转化为字符串病输出用逗号分割的字符串列表；toLocaleString()把数组里每个元素转换为本地字符串。 ECMAScript5数组方法10、Array.prototype.forEach()从头至尾遍历数组，为每个元素调用指定的函数。详细参考 11、Array.prototype.map()将调用的数组每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。map()返回的是新数组，它不修改调用数组。 12、Array.prototype.filter()返回的数组元素是调用的数组的一个子集。会跳过稀疏数组中缺少的元素，压缩空缺并删除undefined和null元素。12345function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] 13、every()和some()数组逻辑判定，他们对数组元素应用指定的函数进行判定，返回true或false1234567891011function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is truevar passed2 = [12, 5, 8, 130, 44].every(isBigEnough);// passed2 is falsepassed2 = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true 14、reduce()和reduceRight()reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）123456var a = [\"1\", \"2\", \"3\", \"4\", \"5\"]; var left = a.reduce(function(prev, cur) &#123; return prev + cur; &#125;); var right = a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;); console.log(left); // \"12345\"console.log(right); // \"54321\" 15、indexOf()和lastIndexOf()indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 lastIndexOf() 123456var array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 找出指定元素出现的所有位置 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.indexOf(element);while (idx != -1) &#123; indices.push(idx); idx = array.indexOf(element, idx + 1);&#125;console.log(indices);// [0, 2, 4] lastIndexOf() 12345678910111213var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"},{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"分享一个国外在线图片压缩网站","date":"2016-12-22T18:29:41.000Z","path":"2016/12/23/分享一个国外在线图片压缩网站/","text":"TinyPNG用聪明的有损压缩技术来减少你的PNG文件的文件大小。通过选择性地减少图像中的颜色数，则需要更少的字节来存储数据。变化效果几乎看不见，但它使文件大小有很大的差异！ https://tinypng.com/","tags":[]},{"title":"输入URL到页面加载完成的过程都发生了什么事情","date":"2016-12-22T17:30:34.000Z","path":"2016/12/23/输入URL到页面加载完成的过程都发生了什么事情/","text":"1.输入url,按下回车后，这时你的浏览器首先查询DNS服务器，将url转换成ip地址。2.DNS查询之后，返回IP地址给浏览器。3.有了 IP 地址，就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议。4.浏览器给web服务器发送一个HTTP请求。5.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）。6.浏览器跟踪重定向地址。7.服务器处理请求。8.服务器返回一个 HTTP 响应。9.浏览器显示 HTML。10.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）。11.将渲染好的页面图像显示出来，并开始响应用户的操作。12.浏览器发送异步请求。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"JavaScript作用域和闭包","date":"2016-12-21T20:09:11.000Z","path":"2016/12/22/JavaScript作用域和闭包/","text":"前言：JavaScript是一种应用非常广泛的语言，其也有一些自身特点和优势，本文重在讲述其作用域机制以及闭包，会从一些实例来探讨其机理。 作用域在JavaScript程序员日常使用中有不同的含义，如下所示： this绑定的值；this绑定的值定义的执行上下文；一个变量的“生命周期”；变量的值解析方案，或词法绑定。下面将讲诉JavaScript作用域概念，由此引出变量值解析方案的一般想法，最后再探讨JavaScript里闭包这一重要知识点。 1.全局作用域所有浏览器都支持 window 对象，它表示浏览器窗口，JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。所以，全局变量是 window 对象的属性，全局函数是 window 对象的方法，甚至 HTML DOM 的 document 也是 window 对象的属性之一。 全局变量是JavaScript里生命周期（一个变量多长时间内保持一定的值）最长的变量，其将跨越整个程序，可以被程序中的任何函数方法访问。 在全局下声明的变量都会在window对象下，都在全局作用域中，我们可以通过window对象访问，也可以直接访问。123var name = \"jeri\";console.log(window.name); // 输出:jericonsole.log(name); // 输出:jeri 在JS中任何位置，没有使用var关键字声明的变量也都是全局变量。12345function fun() &#123; name = \"jeri\"; alert(name);&#125;console.log(name); // 输出:jeri 全局变量存在于整个函数的生命周期中，然而其在全局范围内很容易被篡改，我们在使用全局变量时一定要小心，尽量不要使用全局变量。在函数内部声明变量没有使用var也会产生全局变量，会为我们造成一些混乱，比如变量覆盖等。所以，我们在声明变量的任何时候最好都要带上var。 全局变量存在于程序的整个生命周期，但并不是通过其引用我们一定可以访问到全局变量。 2.词法作用域词法作用域：函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。词法作用域也可以理解为一个变量的可见性，及其文本表述的模拟值。12345678var name = \"global\";function fun() &#123; var name = \"jeri\"; return name;&#125;console.log(fun()); // 输出:jericonsole.log(name); // 输出:global 在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。就像上例，先查找离它最近的name=”jeri”，查询完成后就结束了，将第一个获取的值作为变量的值。 3.动态作用域在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。 动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，动态作用域在执行时确定，其生存周期到代码片段执行为止。动态变量存在于动态作用域中，任何给定的绑定的值，在确定调用其函数之前，都是不可知的。 在代码执行时，对应的作用域链常常是保持静态的。然而当遇到with语句、call方法、apply方法和try-catch中的catch时，会改变作用域链的。以with为例，在遇到with语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。当with语句执行完毕后，会把作用域链恢复到原始状态。实例如下：1234567891011 var name = \"global\"; // 使用with之前 console.log(name); // 输出:global with(&#123;name:\"jeri\"&#125;)&#123; console.log(name); // 输出:jeri &#125; // 使用with之后，作用域链恢复console.log(name); // 输出:global 在作用域链中有动态作用域时，this引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用apply或call方法时，传入它们的第一个参数就是被引用的对象。实例如下：1234567function globalThis() &#123; console.log(this);&#125;globalThis(); // 输出:Window &#123;document: document,external: Object…&#125;globalThis.call(&#123;name:\"jeri\"&#125;); // 输出:Object &#123;name: \"jeri\"&#125;globalThis.apply(&#123;name:\"jeri\"&#125;,[]); // 输出:Object &#123;name: \"jeri\"&#125; 因为this引用是动态作用域，所以在编程过程中一定要注意this引用的变化，及时跟踪this的变动。 4.函数作用域函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为局部作用域。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：12345678910111213141516 var name = \"global\"; function fun() &#123; var name = \"jeri\"; console.log(name); // 输出:jeri with (&#123;name:\"with\"&#125;) &#123; console.log(name); // 输出:with &#125; console.log(name); // 输出:jeri&#125;fun();// 不能访问函数作用域console.log(name); // 输出:global 5.没有块级作用域不同于其他编程语言，在JavaScript里并没有块级作用域，也就是说在for、if、while等语句内部的声明的变量与在外部声明是一样的，在这些语句外部也可以访问和修改这些变量的值。实例如下：1234567891011 function fun() &#123; if(0 &lt; 2) &#123; var name = \"jeri\"; &#125; console.log(name); // 输出:jeri name = \"change\"; console.log(name); // 输出:change &#125;fun(); 6.作用域链JavaScript里一切皆为对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是作用域，包含了函数被创建的作用域中对象的集合，称为函数的作用域链，它用来保证对执行环境有权访问的变量和函数的有序访问。 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。在全局作用域中创建的函数，其作用域链会自动成为全局作用域中的一员。而当函数执行时，其活动对象就会成为作用域链中的第一个对象（活动对象：对象包含了函数的所有局部变量、命名参数、参数集合以及this）。在程序执行时，Javascript引擎会通过搜索上下文的作用域链来解析诸如变量和函数名这样的标识符。其会从作用域链的最里面开始检索，按照由内到外的顺序，直到完成查找，一旦完成查找就结束搜索。如果没有查询到标识符声明，则报错。当函数执行结束，运行期上下文被销毁，活动对象也随之销毁。实例如下：12345678910111213141516 var name = 'global'; function fun() &#123; console.log(name); // output:global name = \"change\"; // 函数内部可以修改全局变量 console.log(name); // output:change // 先查询活动对象 var age = \"18\"; console.log(age); // output:18&#125;fun();// 函数执行完毕，执行环境销毁console.log(age); // output:Uncaught ReferenceError: age is not defined 7.闭包闭包是JavaScript的一大谜团，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻。闭包的官方定义为：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 一句话概括就是：闭包就是一个函数，捕获作用域内的外部绑定。这些绑定是为之后使用而被绑定，即使作用域已经销毁。 自由变量 自由变量与闭包的关系是，自由变量闭合于闭包的创建。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中return语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。实例如下： 12345678910 function makeAdder(captured) &#123; return function(free) &#123; var ret = free + captured; console.log(ret); &#125; &#125; var add10 = makeAdder(10); add10(2); // 输出:12 从上例可知，外部函数中的变量captured被执行加法的返回函数捕获，内部函数从未声明过captured变量，却可以引用它。 如果我们再创建一个加法器将捕获到同名变量captured，但有不同的值，因为这个加法器是在调用makeAdder之后被创建：12345var add16 = makeAdder(16);add16(18); // 输出:24add10(10); // 输出:20 如上述代码所示，每一个新的加法器函数都保留了自己创建时捕获的captured实例。 变量遮蔽 在JavaScript中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生变量的遮蔽。实例如下：123456789101112var name = \"jeri\";var name = \"tom\";function glbShadow() &#123; var name = \"fun\"; console.log(name); // 输出:fun&#125;glbShadow();console.log(name); // 输出:tom 当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。 变量声明的遮蔽很好理解，然而函数参数的遮蔽就略显复杂。例如：12345678910var shadowed = 0;function argShadow(shadowed) &#123; var str = [\"Value is\",shadowed].join(\" \"); console.log(str);&#125;argShadow(108); // output:Value is 108argShadow(); // output:Value is 函数argShadow的参数shadowed覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是shadowed，并没有访问到全局变量shadowed = 0。 任何情况下，离得最近的变量绑定优先级最高。实例如下：12345678910var shadowed = 0; function varShadow(shadowed) &#123; var shadowed = 123; var str = [\"Value is\",shadowed].join(\" \"); console.log(str);&#125;varShadow(108); // output:Value is 123varShadow(); // output:Value is 123 varShadow(108)打印出来的并不是108而是123，即使没有参数传入也是打印的123，先访问离得最近的变量绑定。 遮蔽变量同样发生在闭包内部，实例如下：12345678910 function captureShadow(shadowed) &#123; console.log(shadowed); // output:108 return function(shadowed) &#123; console.log(shadowed); // output:2 var ret = shadowed + 1; console.log(ret); // output:3 &#125;&#125;var closureShadow = captureShadow(108);closureShadow(2); 在编写JavaScript代码时，因为变量遮蔽会使很多变量绑定超出我们的控制，我们应尽量避免变量遮蔽，一定要注意变量命名。 典型误区 下面是一个非常典型的问题，曾经困扰了很多人，下面也来探讨下。12345678910111213141516 var test = function() &#123; var ret = []; for(var i = 0; i &lt; 5; i++) &#123; ret[i] = function() &#123; return i; &#125; &#125; return ret;&#125;;var test0 = test()[0]();console.log(test0); // 输出：5var test1 = test()[1]();console.log(test1); //输出：5 从上面的例子可知，test这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量i=5。 下面有个更优雅的例子来表述这个问题：12345678for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;// 每隔1秒输出一个5 按照我们的推断，上例应该输出1,2,3,4,5。然而，事实上输出的是连续5个5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。 上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用setTimeout时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是5了。 那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出5个5的状况。实例如下：1234567891011 for(var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125;// 输出：0,1,2,3,4 闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是javascript语言的一大特点，主要应用闭包场合为：设计私有的方法和变量。 模拟私有变量 从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量作为私有变量。实例如下：12345678910111213141516171819202122232425262728 var closureDemo = (function() &#123; var PRIVATE = 0; return &#123; inc:function(n) &#123; return PRIVATE += n; &#125;, dec:function(n) &#123; return PRIVATE -= n; &#125; &#125;;&#125;)();var testInc = closureDemo.inc(10);//console.log(testInc);// 输出：10var testDec = closureDemo.dec(7);//console.log(testDec);// 输出：3closureDemo.div = function(n) &#123; return PRIVATE / n;&#125;;var testDiv = closureDemo.div(3);console.log(testDiv);//输出：Uncaught ReferenceError: PRIVATE is not defined 自执行函数closureDemo执行完毕之后，自执行函数作用域和PRIVATE随之销毁，但PRIVATE仍滞留在内存中，也就是加入到closureDemo.inc和closureDemo.dec的作用域链中，闭包也就完成了变量的捕获。但之后新加入的closureDemo.div并不能在作用域中继续寻找到PRIVATE了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的div方法并不能捕获PRIVATE。 创建特权方法 通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：1234567891011121314151617181920(function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFun() &#123; return false; &#125;; // 构造函数 MyObj = function() &#123; &#125;; // 公有/特权方法 MyObj.prototype.publicMethod = function() &#123; privateVar ++; return privateFun(); &#125;&#125;)(); 上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明MyObj这个函数时，使用的是不带var的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法publicMethod也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。 总的来说，因为闭包奇特的特性，可以通过它实现一些强大的功能。但，我们在日常编程中，也要正确的使用闭包，要时刻注意回收不用的变量，避免内存泄露。 文章来源：http://www.cnblogs.com/syfwhu/p/4839562.html","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"},{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"CSS高级布局技巧","date":"2016-12-21T19:21:36.000Z","path":"2016/12/22/CSS高级布局技巧/","text":"用 :empty 区分空元素 兼容性：不支持 IE8 demo假如我们有以上列表： 123&lt;div class=\"item\"&gt;a&lt;/div&gt;&lt;div class=\"item\"&gt;b&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt; 我们希望可以对空元素和非空元素区别处理，那么有两种方案。 用 :empty 选择空元素：123.item:empty &#123; display: none;&#125; 或者用 :not(:empty) 选择非空元素：1234.item:not(:empty) &#123; border: 1px solid #ccc; /* ... */&#125; 用 :*-Of-Type 选择元素 兼容性：不支持 IE8 举例说明。给第一个 p 段落加粗：123p:first-of-type &#123; font-weight: bold;&#125; 给最后一个 img 加边框：123img:last-of-type &#123; border: 10px solid #ccc;&#125; 给无相连的 blockquote 加样式：1234blockquote:only-of-type &#123; border-left: 5px solid #ccc; padding-left: 2em;&#125; 让奇数列的 p 段落显示红色：123p:nth-of-type(even) &#123; color: red;&#125; 此外，:nth-of-type 还可以有其他类型的参数：12345678/* 偶数个 */:nth-of-type(even)/* only 第三个 */:nth-of-type(3)/* 每第三个 */:nth-of-type(3n)/* 每第四加三个，即 3, 7, 11, ... */:nth-of-type(4n+3) 用 calc 做流式布局 兼容性：不支持 IE8 demo左中右的流式布局：123456789101112131415161718nav &#123; position: fixed; left: 0; top: 0; width: 5rem; height: 100%;&#125;aside &#123; position: fixed; right: 0; top: 0; width: 20rem; height: 100%;&#125;main &#123; margin-left: 5rem; width: calc(100% - 25rem);&#125; 用 vw 和 vh 做全屏滚动效果 兼容性：不支持 IE8 demovw 和 vh 是相对于 viewport 而言的，所以不会随内容和布局的变化而变。12345678910111213141516171819202122232425262728293031section &#123; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; text-align: center; background-size: cover; background-repeat: no-repeat; background-attachment: fixed;&#125;section:nth-of-type(1) &#123; background-image: url('https://unsplash.it/1024/683?image=1068');&#125;section:nth-of-type(2) &#123; background-image: url('https://unsplash.it/1024/683?image=1073');&#125;section:nth-of-type(3) &#123; background-image: url('https://unsplash.it/1024/683?image=1047');&#125;section:nth-of-type(4) &#123; background-image: url('https://unsplash.it/1024/683?image=1032');&#125;body &#123; margin: 0;&#125;p &#123; color: #fff; font-size: 100px; font-family: monospace;&#125; 用 unset 做 CSS Reset 兼容性：不支持 IE Demo 123456789101112body &#123; color: red;&#125;button &#123; color: white; border: 1px solid #ccc;&#125;/* 取消 section 中 button 的 color 设置 */section button &#123; color: unset;&#125; 用 column 做响应式的列布局 兼容性：不支持 IE9 Demo12345678910nav &#123; column-count: 4; column-width: 150px; column-gap: 3rem; column-rule: 1px dashed #ccc; column-fill: auto;&#125;h2 &#123; column-span: all;&#125; 文章来源：https://github.com/sorrycc/blog/issues/14","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"},{"name":"CSS","slug":"CSS","permalink":"http://vicenlaw.com/tags/CSS/"}]},{"title":"JS对象","date":"2016-12-21T17:21:45.000Z","path":"2016/12/22/JS对象/","text":"测试文章12var oObject = new Object();var oStringObject = new String();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"},{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"Hello World","date":"2016-08-13T18:07:42.000Z","path":"2016/08/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]