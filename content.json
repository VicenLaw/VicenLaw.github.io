[{"title":"Js数组方法","date":"2016-12-24T17:09:58.000Z","path":"2016/12/25/Js数组方法/","text":"数组方法1、Array.prototype.join()将数组中所有元素化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分割数组的各个元素。如不指定分隔符，默认使用逗号。123456var a = [1, 2, 3];a.join(); // =&gt; \"1,2,3\"a.join(\" \"); // =&gt; \"1 2 3\"a.join(\"\"); // =&gt; \"123\"var b = new Array(3); //长度为3的空数组b.join(\"-\"); // -&gt; \"--\" 2、Array.prototype.reverse()将数组的元素颠倒顺序，返回逆序的数组。12var a = [1, 2, 3];a.reverse(); // a = [3, 2, 1] 3、Array.prototype.sort()将数组中的元素排序，并返回排序后的数组。不带参数的时候，默认以字母表顺序排序（如有必要将临时转化为字符串进行比较）12345678910111213141516171819var a = new Array(\"banana\", \"cherry\", \"apple\");a.sort() // a = [\"apple\", \"banana\", \"cherry\"]//如果数组包含undefined元素，将会排到数组尾部var b = [22, 1, 111, 333];b.sort(); //字母表顺序: b = [1, 111, 22, 333];b.sort(function(a,b)&#123;return a-b;&#125;); //数值排序 b = [1, 22, 111, 333]b.sort(function(a,b)&#123;return b-a;&#125;); //数值大小相反排序//字母大小var c = [\"Dog\", \"Apple\", \"banana\", \"apple\"]；//区分大小写 结果为c=[\"Apple\", \"Dog\", \"apple\", \"banana\"]c.sort(); //不区分大小写，先将参数转化为小写字符串再比较。结果为c=[\"apple\", \"Apple\", \"banana\"， \"Dog\"]c.sort(function (s, t)&#123; var a = s.toLowerCase(); var b = t.toLowerCase(); if(a&lt;b) return -1; if(a&gt;b) return 1; return 0;&#125;); 4、Array.prototype.concat()连接两个或更多的数组，并返回结果。 5、Array.prototype.slice()从某个已有的数组返回选定的元素Array.prototype.slice(start,end)start ：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标（即不包含该参数指定位置）。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。注意： 6、Array.prototype.splice()向数组中添加/删除元素Array.prototype.splice(index,howmany,item1,..itemX)index：必需，整数，方法开始位置howmany：必需，需要删除元素的数量，如果为0则不删除。item1：可选，向数组添新的元素123456789101112var arr = new Array(6) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" arr[3] = \"James\" arr[4] = \"Adrew\" arr[5] = \"Martin\" document.write(arr + \"&lt;br /&gt;\") //George,John,Thomas,James,Adrew,Martin arr.splice(2,0,\"William\") document.write(arr + \"&lt;br /&gt;\") //George,John,William,Thomas,James,Adrew,Martin //注意，不是结果不是George,John,Thomas,William,James,Adrew,Martin 7、Array.prototype.push() , Array.prototype.pop()push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度；pop()方法删除数组最后一个元素，减小数组长度并返回它删除的值。注意：两个方法都修改并替换原始数组，而不是生成一个修改版的新数组。 8、Array.prototype.unshift() , Array.shift()unshift()向数组的开头添加一个或更多元素，并返回新的长度。shift()删除并返回数组的第一个元素 9、Array.prototype.toString() , Array.toLocaleString()toString()将每个元素转化为字符串病输出用逗号分割的字符串列表；toLocaleString()把数组里每个元素转换为本地字符串。 ECMAScript5数组方法10、Array.prototype.forEach()从头至尾遍历数组，为每个元素调用指定的函数。详细参考 11、Array.prototype.map()将调用的数组每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。map()返回的是新数组，它不修改调用数组。 12、Array.prototype.filter()返回的数组元素是调用的数组的一个子集。会跳过稀疏数组中缺少的元素，压缩空缺并删除undefined和null元素。12345function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] 13、every()和some()数组逻辑判定，他们对数组元素应用指定的函数进行判定，返回true或false1234567891011function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is truevar passed2 = [12, 5, 8, 130, 44].every(isBigEnough);// passed2 is falsepassed2 = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true 14、reduce()和reduceRight()reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）123456var a = [\"1\", \"2\", \"3\", \"4\", \"5\"]; var left = a.reduce(function(prev, cur) &#123; return prev + cur; &#125;); var right = a.reduceRight(function(prev, cur) &#123; return prev + cur; &#125;); console.log(left); // \"12345\"console.log(right); // \"54321\" 15、indexOf()和lastIndexOf()indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 lastIndexOf() 123456var array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 找出指定元素出现的所有位置 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.indexOf(element);while (idx != -1) &#123; indices.push(idx); idx = array.indexOf(element, idx + 1);&#125;console.log(indices);// [0, 2, 4] lastIndexOf() 12345678910111213var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"}]},{"title":"分享一个国外在线图片压缩网站","date":"2016-12-22T18:29:41.000Z","path":"2016/12/23/分享一个国外在线图片压缩网站/","text":"TinyPNG用聪明的有损压缩技术来减少你的PNG文件的文件大小。通过选择性地减少图像中的颜色数，则需要更少的字节来存储数据。变化效果几乎看不见，但它使文件大小有很大的差异！ https://tinypng.com/","tags":[]},{"title":"输入URL到页面加载完成的过程都发生了什么事情","date":"2016-12-22T17:30:34.000Z","path":"2016/12/23/输入URL到页面加载完成的过程都发生了什么事情/","text":"1.输入url,按下回车后，这时你的浏览器首先查询DNS服务器，将url转换成ip地址。2.DNS查询之后，返回IP地址给浏览器。3.有了 IP 地址，就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议。4.浏览器给web服务器发送一个HTTP请求。5.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）。6.浏览器跟踪重定向地址。7.服务器处理请求。8.服务器返回一个 HTTP 响应。9.浏览器显示 HTML。10.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）。11.将渲染好的页面图像显示出来，并开始响应用户的操作。12.浏览器发送异步请求。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"JavaScript作用域和闭包","date":"2016-12-21T20:09:11.000Z","path":"2016/12/22/JavaScript作用域和闭包/","text":"前言：JavaScript是一种应用非常广泛的语言，其也有一些自身特点和优势，本文重在讲述其作用域机制以及闭包，会从一些实例来探讨其机理。 作用域在JavaScript程序员日常使用中有不同的含义，如下所示： this绑定的值；this绑定的值定义的执行上下文；一个变量的“生命周期”；变量的值解析方案，或词法绑定。下面将讲诉JavaScript作用域概念，由此引出变量值解析方案的一般想法，最后再探讨JavaScript里闭包这一重要知识点。 1.全局作用域所有浏览器都支持 window 对象，它表示浏览器窗口，JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。所以，全局变量是 window 对象的属性，全局函数是 window 对象的方法，甚至 HTML DOM 的 document 也是 window 对象的属性之一。 全局变量是JavaScript里生命周期（一个变量多长时间内保持一定的值）最长的变量，其将跨越整个程序，可以被程序中的任何函数方法访问。 在全局下声明的变量都会在window对象下，都在全局作用域中，我们可以通过window对象访问，也可以直接访问。123var name = \"jeri\";console.log(window.name); // 输出:jericonsole.log(name); // 输出:jeri 在JS中任何位置，没有使用var关键字声明的变量也都是全局变量。12345function fun() &#123; name = \"jeri\"; alert(name);&#125;console.log(name); // 输出:jeri 全局变量存在于整个函数的生命周期中，然而其在全局范围内很容易被篡改，我们在使用全局变量时一定要小心，尽量不要使用全局变量。在函数内部声明变量没有使用var也会产生全局变量，会为我们造成一些混乱，比如变量覆盖等。所以，我们在声明变量的任何时候最好都要带上var。 全局变量存在于程序的整个生命周期，但并不是通过其引用我们一定可以访问到全局变量。 2.词法作用域词法作用域：函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。词法作用域也可以理解为一个变量的可见性，及其文本表述的模拟值。12345678var name = \"global\";function fun() &#123; var name = \"jeri\"; return name;&#125;console.log(fun()); // 输出:jericonsole.log(name); // 输出:global 在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。就像上例，先查找离它最近的name=”jeri”，查询完成后就结束了，将第一个获取的值作为变量的值。 3.动态作用域在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。 动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，动态作用域在执行时确定，其生存周期到代码片段执行为止。动态变量存在于动态作用域中，任何给定的绑定的值，在确定调用其函数之前，都是不可知的。 在代码执行时，对应的作用域链常常是保持静态的。然而当遇到with语句、call方法、apply方法和try-catch中的catch时，会改变作用域链的。以with为例，在遇到with语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。当with语句执行完毕后，会把作用域链恢复到原始状态。实例如下：1234567891011 var name = \"global\"; // 使用with之前 console.log(name); // 输出:global with(&#123;name:\"jeri\"&#125;)&#123; console.log(name); // 输出:jeri &#125; // 使用with之后，作用域链恢复console.log(name); // 输出:global 在作用域链中有动态作用域时，this引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用apply或call方法时，传入它们的第一个参数就是被引用的对象。实例如下：1234567function globalThis() &#123; console.log(this);&#125;globalThis(); // 输出:Window &#123;document: document,external: Object…&#125;globalThis.call(&#123;name:\"jeri\"&#125;); // 输出:Object &#123;name: \"jeri\"&#125;globalThis.apply(&#123;name:\"jeri\"&#125;,[]); // 输出:Object &#123;name: \"jeri\"&#125; 因为this引用是动态作用域，所以在编程过程中一定要注意this引用的变化，及时跟踪this的变动。 4.函数作用域函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为局部作用域。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：12345678910111213141516 var name = \"global\"; function fun() &#123; var name = \"jeri\"; console.log(name); // 输出:jeri with (&#123;name:\"with\"&#125;) &#123; console.log(name); // 输出:with &#125; console.log(name); // 输出:jeri&#125;fun();// 不能访问函数作用域console.log(name); // 输出:global 5.没有块级作用域不同于其他编程语言，在JavaScript里并没有块级作用域，也就是说在for、if、while等语句内部的声明的变量与在外部声明是一样的，在这些语句外部也可以访问和修改这些变量的值。实例如下：1234567891011 function fun() &#123; if(0 &lt; 2) &#123; var name = \"jeri\"; &#125; console.log(name); // 输出:jeri name = \"change\"; console.log(name); // 输出:change &#125;fun(); 6.作用域链JavaScript里一切皆为对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是作用域，包含了函数被创建的作用域中对象的集合，称为函数的作用域链，它用来保证对执行环境有权访问的变量和函数的有序访问。 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。在全局作用域中创建的函数，其作用域链会自动成为全局作用域中的一员。而当函数执行时，其活动对象就会成为作用域链中的第一个对象（活动对象：对象包含了函数的所有局部变量、命名参数、参数集合以及this）。在程序执行时，Javascript引擎会通过搜索上下文的作用域链来解析诸如变量和函数名这样的标识符。其会从作用域链的最里面开始检索，按照由内到外的顺序，直到完成查找，一旦完成查找就结束搜索。如果没有查询到标识符声明，则报错。当函数执行结束，运行期上下文被销毁，活动对象也随之销毁。实例如下：12345678910111213141516 var name = 'global'; function fun() &#123; console.log(name); // output:global name = \"change\"; // 函数内部可以修改全局变量 console.log(name); // output:change // 先查询活动对象 var age = \"18\"; console.log(age); // output:18&#125;fun();// 函数执行完毕，执行环境销毁console.log(age); // output:Uncaught ReferenceError: age is not defined 7.闭包闭包是JavaScript的一大谜团，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻。闭包的官方定义为：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 一句话概括就是：闭包就是一个函数，捕获作用域内的外部绑定。这些绑定是为之后使用而被绑定，即使作用域已经销毁。 自由变量 自由变量与闭包的关系是，自由变量闭合于闭包的创建。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中return语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。实例如下： 12345678910 function makeAdder(captured) &#123; return function(free) &#123; var ret = free + captured; console.log(ret); &#125; &#125; var add10 = makeAdder(10); add10(2); // 输出:12 从上例可知，外部函数中的变量captured被执行加法的返回函数捕获，内部函数从未声明过captured变量，却可以引用它。 如果我们再创建一个加法器将捕获到同名变量captured，但有不同的值，因为这个加法器是在调用makeAdder之后被创建：12345var add16 = makeAdder(16);add16(18); // 输出:24add10(10); // 输出:20 如上述代码所示，每一个新的加法器函数都保留了自己创建时捕获的captured实例。 变量遮蔽 在JavaScript中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生变量的遮蔽。实例如下：123456789101112var name = \"jeri\";var name = \"tom\";function glbShadow() &#123; var name = \"fun\"; console.log(name); // 输出:fun&#125;glbShadow();console.log(name); // 输出:tom 当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。 变量声明的遮蔽很好理解，然而函数参数的遮蔽就略显复杂。例如：12345678910var shadowed = 0;function argShadow(shadowed) &#123; var str = [\"Value is\",shadowed].join(\" \"); console.log(str);&#125;argShadow(108); // output:Value is 108argShadow(); // output:Value is 函数argShadow的参数shadowed覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是shadowed，并没有访问到全局变量shadowed = 0。 任何情况下，离得最近的变量绑定优先级最高。实例如下：12345678910var shadowed = 0; function varShadow(shadowed) &#123; var shadowed = 123; var str = [\"Value is\",shadowed].join(\" \"); console.log(str);&#125;varShadow(108); // output:Value is 123varShadow(); // output:Value is 123 varShadow(108)打印出来的并不是108而是123，即使没有参数传入也是打印的123，先访问离得最近的变量绑定。 遮蔽变量同样发生在闭包内部，实例如下：12345678910 function captureShadow(shadowed) &#123; console.log(shadowed); // output:108 return function(shadowed) &#123; console.log(shadowed); // output:2 var ret = shadowed + 1; console.log(ret); // output:3 &#125;&#125;var closureShadow = captureShadow(108);closureShadow(2); 在编写JavaScript代码时，因为变量遮蔽会使很多变量绑定超出我们的控制，我们应尽量避免变量遮蔽，一定要注意变量命名。 典型误区 下面是一个非常典型的问题，曾经困扰了很多人，下面也来探讨下。12345678910111213141516 var test = function() &#123; var ret = []; for(var i = 0; i &lt; 5; i++) &#123; ret[i] = function() &#123; return i; &#125; &#125; return ret;&#125;;var test0 = test()[0]();console.log(test0); // 输出：5var test1 = test()[1]();console.log(test1); //输出：5 从上面的例子可知，test这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量i=5。 下面有个更优雅的例子来表述这个问题：12345678for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;// 每隔1秒输出一个5 按照我们的推断，上例应该输出1,2,3,4,5。然而，事实上输出的是连续5个5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。 上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用setTimeout时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是5了。 那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出5个5的状况。实例如下：1234567891011 for(var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125;// 输出：0,1,2,3,4 闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是javascript语言的一大特点，主要应用闭包场合为：设计私有的方法和变量。 模拟私有变量 从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量作为私有变量。实例如下：12345678910111213141516171819202122232425262728 var closureDemo = (function() &#123; var PRIVATE = 0; return &#123; inc:function(n) &#123; return PRIVATE += n; &#125;, dec:function(n) &#123; return PRIVATE -= n; &#125; &#125;;&#125;)();var testInc = closureDemo.inc(10);//console.log(testInc);// 输出：10var testDec = closureDemo.dec(7);//console.log(testDec);// 输出：3closureDemo.div = function(n) &#123; return PRIVATE / n;&#125;;var testDiv = closureDemo.div(3);console.log(testDiv);//输出：Uncaught ReferenceError: PRIVATE is not defined 自执行函数closureDemo执行完毕之后，自执行函数作用域和PRIVATE随之销毁，但PRIVATE仍滞留在内存中，也就是加入到closureDemo.inc和closureDemo.dec的作用域链中，闭包也就完成了变量的捕获。但之后新加入的closureDemo.div并不能在作用域中继续寻找到PRIVATE了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的div方法并不能捕获PRIVATE。 创建特权方法 通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：1234567891011121314151617181920(function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFun() &#123; return false; &#125;; // 构造函数 MyObj = function() &#123; &#125;; // 公有/特权方法 MyObj.prototype.publicMethod = function() &#123; privateVar ++; return privateFun(); &#125;&#125;)(); 上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明MyObj这个函数时，使用的是不带var的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法publicMethod也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。 总的来说，因为闭包奇特的特性，可以通过它实现一些强大的功能。但，我们在日常编程中，也要正确的使用闭包，要时刻注意回收不用的变量，避免内存泄露。 文章来源：http://www.cnblogs.com/syfwhu/p/4839562.html","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"}]},{"title":"CSS高级布局技巧","date":"2016-12-21T19:21:36.000Z","path":"2016/12/22/CSS高级布局技巧/","text":"用 :empty 区分空元素 兼容性：不支持 IE8 demo假如我们有以上列表： 123&lt;div class=\"item\"&gt;a&lt;/div&gt;&lt;div class=\"item\"&gt;b&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt; 我们希望可以对空元素和非空元素区别处理，那么有两种方案。 用 :empty 选择空元素：123.item:empty &#123; display: none;&#125; 或者用 :not(:empty) 选择非空元素：1234.item:not(:empty) &#123; border: 1px solid #ccc; /* ... */&#125; 用 :*-Of-Type 选择元素 兼容性：不支持 IE8 举例说明。给第一个 p 段落加粗：123p:first-of-type &#123; font-weight: bold;&#125; 给最后一个 img 加边框：123img:last-of-type &#123; border: 10px solid #ccc;&#125; 给无相连的 blockquote 加样式：1234blockquote:only-of-type &#123; border-left: 5px solid #ccc; padding-left: 2em;&#125; 让奇数列的 p 段落显示红色：123p:nth-of-type(even) &#123; color: red;&#125; 此外，:nth-of-type 还可以有其他类型的参数：12345678/* 偶数个 */:nth-of-type(even)/* only 第三个 */:nth-of-type(3)/* 每第三个 */:nth-of-type(3n)/* 每第四加三个，即 3, 7, 11, ... */:nth-of-type(4n+3) 用 calc 做流式布局 兼容性：不支持 IE8 demo左中右的流式布局：123456789101112131415161718nav &#123; position: fixed; left: 0; top: 0; width: 5rem; height: 100%;&#125;aside &#123; position: fixed; right: 0; top: 0; width: 20rem; height: 100%;&#125;main &#123; margin-left: 5rem; width: calc(100% - 25rem);&#125; 用 vw 和 vh 做全屏滚动效果 兼容性：不支持 IE8 demovw 和 vh 是相对于 viewport 而言的，所以不会随内容和布局的变化而变。12345678910111213141516171819202122232425262728293031section &#123; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; text-align: center; background-size: cover; background-repeat: no-repeat; background-attachment: fixed;&#125;section:nth-of-type(1) &#123; background-image: url('https://unsplash.it/1024/683?image=1068');&#125;section:nth-of-type(2) &#123; background-image: url('https://unsplash.it/1024/683?image=1073');&#125;section:nth-of-type(3) &#123; background-image: url('https://unsplash.it/1024/683?image=1047');&#125;section:nth-of-type(4) &#123; background-image: url('https://unsplash.it/1024/683?image=1032');&#125;body &#123; margin: 0;&#125;p &#123; color: #fff; font-size: 100px; font-family: monospace;&#125; 用 unset 做 CSS Reset 兼容性：不支持 IE Demo 123456789101112body &#123; color: red;&#125;button &#123; color: white; border: 1px solid #ccc;&#125;/* 取消 section 中 button 的 color 设置 */section button &#123; color: unset;&#125; 用 column 做响应式的列布局 兼容性：不支持 IE9 Demo12345678910nav &#123; column-count: 4; column-width: 150px; column-gap: 3rem; column-rule: 1px dashed #ccc; column-fill: auto;&#125;h2 &#123; column-span: all;&#125; 文章来源：https://github.com/sorrycc/blog/issues/14","tags":[{"name":"CSS","slug":"CSS","permalink":"http://vicenlaw.com/tags/CSS/"},{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"}]},{"title":"JS对象","date":"2016-12-21T17:21:45.000Z","path":"2016/12/22/JS对象/","text":"测试文章12var oObject = new Object();var oStringObject = new String();","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://vicenlaw.com/tags/前端开发/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://vicenlaw.com/tags/JavaScript/"}]},{"title":"Hello World","date":"2016-08-13T18:07:42.000Z","path":"2016/08/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]